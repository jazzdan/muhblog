<hr />

<p>title: Hello hello world</p>

<h2>draft: true</h2>

<p>TODO: maybe only reference 0.6.0 docs as they might not be as ephemeral and also</p>

<p>Languages are often judged initially on their &quot;<a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">Hello,
world!</a>&quot; program.
How easy is it to write? To run? How easy is it to understand? It's a very
simple program, of course, one of the simplest, even... just produce a little
text, and display it, what could be simpler?</p>

<p>It's really not fair to judge a language by such a cursory impression, but it
<em>can</em> give you an idea of what a language <em>values</em> and how it works. What does
the syntax look like? Is it typed? Is it interpreted? You can usually tell a
lot at a glance.</p>

<p>For example, One of Ruby's (many) hello worlds is so simple, it's also Python!</p>

<p><code>ruby
print('Hello world!')
</code></p>

<p>Often, people coming from interpreted languages experience compiled, systems
languages to be more complicated right off the bat. There is the obvious added
complexity of compiling and running as separate steps, as opposed to simply
pointing an executable at some source code and seeing a result right away, but
there are often syntactical constructs to go along with that..</p>

<p>At first glance, Rust's hello world looks fairly inert, too:</p>

<p><code>rust
fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></p>

<p>But <code>println!</code> is actually a macro, what does it look like expanded?</p>

<p><code>rust
macro_rules! println {
    () =&gt; ($crate::print!(&quot;\n&quot;));
    ($($arg:tt)*) =&gt; ({
        $crate::io::_print($crate::format_args_nl!($($arg)*));
    })
}
</code></p>

<p>You'll notice that this <em>also</em> has a macro <em>inside of it.</em> This calls into <code>print!</code> which expands to call into</p>

<p><code>rust
macro_rules! print {
    ($($arg:tt)*) =&gt; ($crate::io::_print($crate::format_args!($($arg)*)));
}
</code></p>

<p><code>io::_print</code> which calls into</p>

<p><code>rust
pub fn _print(args: fmt::Arguments&lt;'_&gt;) {
    print_to(args, &amp;LOCAL_STDOUT, stdout, &quot;stdout&quot;);
}
</code></p>

<p><code>print_to</code> which looks like</p>

<p>```rust
fn print<em>to<T>(
 args: fmt::Arguments&lt;'</em>&gt;,
 local<em>s: &amp;'static LocalKey&lt;RefCell&lt;Option&lt;Box&lt;dyn Write + Send&gt;&gt;&gt;&gt;,
 global</em>s: fn() -&gt; T,
 label: &amp;str,
) where
 T: Write,
{
 let result = local<em>s
 .try</em>with(|s| {
 // Note that we completely remove a local sink to write to in case
 // our printing recursively panics/prints, so the recursive
 // panic/print goes to the global sink instead of our local sink.
 let prev = s.borrow<em>mut().take();
 if let Some(mut w) = prev {
 let result = w.write</em>fmt(args);
 *s.borrow<em>mut() = Some(w);
 return result;
 }
 global</em>s().write<em>fmt(args)
 })
 .unwrap</em>or<em>else(|</em>| global<em>s().write</em>fmt(args));</p>

<pre><code>if let Err(e) = result {
    panic!(&quot;failed printing to {}: {}&quot;, label, e);
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Which is, uh, well let's just say it's not exactly clear what's happening at a
glance. There is a lot going on here!</p>

<p>Now, to be clear, I'm not faulting Rust here at all, my point is exactly the
opposite actually, in that there is <em>always</em> necessarily more going on in a
hello world than <code>puts &quot;la da da&quot;</code> or similar would have you believe on its
face. Speaking of Ruby's <code>puts</code>, what <em>is</em> the code that runs <code>puts</code> in the
Ruby interpreter itself, which is written in C?</p>

<p>Well it looks like <a href="https://github.com/ruby/ruby/blob/7c2bbd1c7d40a30583844d649045824161772e36/io.c#L7727-L7758">this</a></p>

<p>```c
VALUE
rb<em>io</em>puts(int argc, const VALUE *argv, VALUE out)
{
 int i, n;
 VALUE line, args[2];</p>

<pre><code>/* if no argument given, print newline. */
if (argc == 0) {
    rb_io_write(out, rb_default_rs);
    return Qnil;
}
for (i=0; i&lt;argc; i++) {
    if (RB_TYPE_P(argv[i], T_STRING)) {
        line = argv[i];
        goto string;
    }
    if (rb_exec_recursive(io_puts_ary, argv[i], out)) {
        continue;
    }
    line = rb_obj_as_string(argv[i]);
  string:
    n = 0;
    args[n++] = line;
    if (RSTRING_LEN(line) == 0 ||
        !rb_str_end_with_asciichar(line, '\n')) {
        args[n++] = rb_default_rs;
    }
    rb_io_writev(out, n, args);
}

return Qnil;
</code></pre>

<p>}
```</p>

<p>Hello world!</p>

<p>We all know that a languages like Ruby or Python are designed explicitly to
hide this sort of complexity from us and let us get on with the dirty business
of munging data blobs or serving web requests or whatever, and thank goodness
for that, but wow that <em>is</em> a lot, isn't it?</p>

<hr />

<p>I think when people come from languages that were designed to be ergonomic to
more systems oriented languages, they're often jarred by what they perceive to
be inelegant, ugly, and verbose code. And to be sure, it <em>is</em> sometimes exactly
that, but usually, the tradeoff is explicit: elegance and simplicity for
<em>control</em>... for specific, granular control over the program that is
eventually run. It isn't always necessary, in fact almost always UNnecessary,
to have <em>that</em> much control over your program. Obviously, productivity matters,
and if your business is <em><em>insert business</em></em>, well it's quite likely
that your goals are not going to be optimally met by futzing with manual memory
management all day (<a href="https://danluu.com/sounds-easy/">at least from the macro level, in the general
sense</a>).</p>

<p>But what if you <em>do</em> need that control? Well then, <em>you need it</em>. When every
ounce of performance is necessary, or on embedded systems, or when writing code
for some bespoke or otherwise uncommon processor.</p>

<p>I'm going to choose one language, Zig, and dive deep into its hello world, but
it is important to note here that my point is not primarily about Zig, it's
about how all languages have to contend with an enormous amount of complexity
in order to do <em>anything</em>, even the simplest of tasks like a hello world
program. Complexity that is, for the most part, hidden from us in our day to
day. So what in the hello world is <em>actually</em> going on then?</p>

<blockquote>
<p>I'll be using the most current minor release version of Zig: 0.6.0.</p>
</blockquote>

<h2>Let's take a walk</h2>

<p><a href="https://ziglang.org/">Zig</a>'s hello world looks like this, from the docs.:</p>

<p>```zig
const std = @import(&quot;std&quot;);</p>

<p>pub fn main() !void {
 const stdout = std.io.getStdOut().outStream();
 try stdout.print(&quot;Hello, {}!\n&quot;, .{&quot;world&quot;});
}
```</p>

<p>If you are new to zig, a quick word on this syntax before I get into the gritty
details.</p>

<p><code>zig
const std = @import(&quot;std&quot;);
</code></p>

<p><code>@import</code> is a <a href="https://ziglang.org/documentation/master/#Builtin-Functions"><em>compiler
builtin</em></a> function
that assigns the namespace of the file it is referencing to the <code>const</code>
variable on the left hand side.</p>

<p><code>zig
pub fn main() !void {
  //...
}
</code>
Just like in C, <code>main</code> is a special function that marks the entry point to a
program after it has been compiled as an executable. Unlike in C, it accepts no
arguments (C's main function has a variety of vagaries that make it a bit
<a href="https://stackoverflow.com/a/4207223">unique</a>) and command line input is
available through utility functions to allow easier cross platform use.</p>

<p>It is marked <a href="https://ziglang.org/documentation/0.6.0/#Keyword-pub"><code>pub</code></a> so
that it is accessible from outside of the immediate module ('module' here
referring to nothing more than the top level scope of the current namespace...
i.e., the file), this is a necessary step since, as the program's entry point,
<code>main</code> would <em>have</em> to be accessible from outside the immediate scope.</p>

<p><code>fn</code> is the function keyword.</p>

<p><code>main()</code> is the name of the function (and where the argument list <em>would</em> be)
and <code>!void</code> is the return type. Looking a little closer at that return type:</p>

<p>In C, the return type of a function is declared <em>before</em> anything else. This
makes a certain amount of sense: it's congruent with how variables are
declared, after all, and scanning the file you can see clearly &quot;calling this
will get you that.&quot;</p>

<p>In Zig, the return type comes after the function declaration but before the
function body. This also makes sense! It's the same in Rust and Go, and seems
to be generally a more modern approach. The reason is actually pretty simple:
doing it this way makes it possible to have a context-free grammar! C and C++
put the parser in a position where it <a href="https://stackoverflow.com/questions/14589346/is-c-context-free-or-context-sensitive">has to understand semantics to even just
<em>parse</em> the source
code.</a></p>

<p>In Zig, <code>main</code> returns <code>void</code> (well, actually, it can return a variety of
things, and if it returns void (which is just a way of saying it doesn't return
anything at all)), it's actually returning
<a href="https://github.com/jfo/zig/blob/7381aaf70e0cad92fc52b79f3aa2a0abb7c3ee04/lib/std/start.zig#L241-L244"><code>0</code></a>
as a success code, but) there is a wrinkle! <code>void</code> is preceded by an
exclamation mark. This means: &quot;This function is supposed to return <code>void</code>, but
it <em>could</em> fail and return an error.&quot; This is an <a href="https://ziglang.org/documentation/master/#Inferred-Error-Sets">inferred error
set</a>, and
whenever a function that <em>could</em> fail is called, the compiler will enforce that
you handle that error at the call site. More on Zig's error handling some other
time, for now it is enough to understand what the <code>!</code> in front of the return
type declaration means. I want to move on to the body of the function, let's go
line by line.</p>

<p><code>zig
const stdout = std.io.getStdOut().outStream();
</code></p>

<p>So, we can see that this is a call into a standard library function (<code>std</code>)
that returns something that we assign to <code>const stdout</code>. Standard out (stdout) and
standard err (stderr) may be familiar concepts from the shell, but what does it
mean to be referring to <code>stdout</code> here in this program? What exactly <em>is</em>
<code>stdout</code>? Whatever it is, it's being returned by the call to <code>outStream()</code>,
which is a method called on the return value of <code>std.io.getStdOut()</code>, so we
first need to know what <em>that</em> is.</p>

<p>To the source! In the Zig source tree, <code>std</code> lives in <code>lib/std/std.zig</code>, which
is a file that makes a wide variety of functionality available. It includes the line:</p>

<p><code>zig
pub const io = @import(&quot;io.zig&quot;);
</code></p>

<p>Which is referred to on the <code>std</code> variable as <code>std.io</code> (again, notice the <code>pub</code>
keyword, without which this declared constant would be inaccesible outside of
this immediate scope). Going deeper, into <code>lib/std/io.zig</code>...</p>

<p><code>zig
pub fn getStdOut() File {
    return File{
        .handle = getStdOutHandle(),
        .capable_io_mode = .blocking,
        .intended_io_mode = default_mode,
    };
}
</code></p>

<p>So, <code>stdout</code> is a <em>File</em> struct. Let's look at that. It is imported at the top
of <code>io.zig</code> as</p>

<p><code>zig
const File = std.fs.File;
</code></p>

<p>and lives in the source, perhaps unsurprisingly, at <code>lib/std/fs/File.zig</code>. This
struct definition is quite long, so I'll focus on what we want to look at, the
<code>outStream()</code> method.</p>

<h2>An aside: methods vs functions</h2>

<p>Zig doesn't <em>really</em> have methods, but it's useful to talk about a special
class of functions <em>as</em> methods, since the calling convention supports implicit
passing of <code>self</code> when called on a struct &quot;instance&quot; using dot syntax. Let me
show you what I mean.</p>

<p>```zig
const std = @import(&quot;std&quot;);</p>

<p>const Thing = struct {
 instanceVariable: u8,
 const classVariable = 41;</p>

<pre><code>fn staticMethod(y: u8) u8 {
    return classVariable + y;
}

fn instanceMethod(self: Thing) u8 {
    return self.instanceVariable;
}
</code></pre>

<p>};</p>

<p>pub fn main() !void {
 std.debug.warn(&quot;{}\n&quot;, .{ Thing.staticMethod(1) }); // 42
 const thing = Thing{ .instanceVariable = 1 };
 std.debug.warn(&quot;{}\n&quot;, .{ thing.instanceMethod() }); // 1
}
```</p>

<p>So, despite the lack of explicit <em>classes</em>, these patterns are available
because of support for this calling convention. Treating a <code>struct</code> <em>like</em> a
class definition, you can call a &quot;static method&quot; on the struct definition
<em>itself</em>. In the example above,</p>

<p><code>zig
Thing.staticMethod(1);
</code></p>

<p>Is equivalent to the</p>

<p><code>ruby
Thing::staticMethod
</code></p>

<p>syntax in Ruby. In fact, the equivalent example in Ruby looks startingly
similar to the Zig version:</p>

<p>```ruby
class Thing
 attr_accessor :instanceVariable
 @@classVariable = 41</p>

<p>def initialize(instanceVariable)
 @instanceVariable = instanceVariable
 end</p>

<p>def self.staticMethod(y)
 @@classVariable + y
 end</p>

<p>def instanceMethod()
 @instanceVariable
 end
end</p>

<p>p Thing::staticMethod(1) # 42
thing = Thing.new(1)
p thing.instanceMethod # 1
```
There are of course notable differences here! Attempting to call a static
method on an <em>instance</em> of a class in ruby</p>

<p><code>ruby
p thing.staticMethod 2
</code>
will not get you very far</p>

<p><code>
thing.rb:21:in `&lt;main&gt;': undefined method `staticMethod' for #&lt;Thing:0x0000000002284d38 @instanceVariable=1&gt; (NoMethodError)
</code></p>

<p>Likewise, the other way:</p>

<p><code>ruby
p Thing::instanceMethod(1)
</code>
<code>
thing.rb:18:in `&lt;main&gt;': undefined method `instanceMethod' for Thing:Class (NoMethodError)
</code></p>

<p>Ruby is a full throated object oriented language, and so of course its
underlying class abstraction is more robust than this facsimile of it in Zig,
but the effect of that is that, well, there's really nothing special about a
zig &quot;instance&quot; vs &quot;static&quot; method, as they are simply functions defined on the
struct that <em>happen</em> to be available through multiple calling conventions.</p>

<p>Take this again, with the same <code>Thing</code> struct definition from above:</p>

<p><code>zig
const thing = Thing{ .instanceVariable = 1 };
std.debug.warn(&quot;{}\n&quot;, .{ thing.staticMethod() });
</code>
You will get a compiler error:</p>

<p><code>
./thing.zig:19:31: error: expected type 'u8', found 'Thing'
    std.debug.warn(&quot;{}\n&quot;, .{ thing.staticMethod() });
</code></p>

<p>But it's telling you that you passed a <code>Thing</code> to the method. This is the
important point: &quot;instance methods&quot; have special access to &quot;instance variables&quot;
because they have a reference to the struct they are being called on, that's
all. That's all the magic there is here.</p>

<blockquote>
<p>Note also that there is nothing special about the word '<em>self</em>', it is
just a conventional variable name.</p>
</blockquote>

<p>For completeness, the other direction:</p>

<p><code>zig
std.debug.warn(&quot;{}\n&quot;, .{ Thing.instanceMethod() });
</code></p>

<p>You will get what you might expect, given the last example:</p>

<p><code>
./thing.zig:17:51: error: expected 1 arguments, found 0
    std.debug.warn(&quot;{}\n&quot;, .{ Thing.instanceMethod() });
</code></p>

<p>No implicit passing of <code>self</code> means an arity error on this call.</p>

<p>But, to underscore the fact that there is nothing magical happening here, you
can indeed do this:</p>

<p><code>zig
const thing = Thing{ .instanceVariable = 1 };
std.debug.warn(&quot;{}\n&quot;, .{ thing.instanceMethod() });
std.debug.warn(&quot;{}\n&quot;, .{ Thing.instanceMethod(thing) });
</code></p>

<p>Those two calls to<code>instanceMethod</code> are the same, but with differing calling
conventions (and so the first one passes <code>self</code> implicitly!)</p>

<h2>The <code>outStream()</code> &quot;method&quot;</h2>

<p>Back in <code>lib/std/fs/File.zig</code>, we see the definition of this &quot;instance method&quot;</p>

<p><code>zig
pub fn outStream(file: File) OutStream {
  return .{ .context = file };
}
</code></p>

<p>This is returning an <code>OutStream</code> struct that is initialized with <code>self</code> of the
<code>File</code> it was called on (here referred to as <code>file</code>). Zig supports <a href="https://ziglang.org/documentation/0.6.0/#Anonymous-Struct-Literals">anonymous
struct
literals</a>
and in this case is able to infer the type based on the return value of the
function. Note too the odd syntax of starting an anonymous struct literal with
<code>.</code>, which is to syntactically distinguish it from a block.</p>

<p>So, further down again, what is an <code>OutStream</code>? Its definition is just above:</p>

<p><code>zig
pub const OutStream = io.OutStream(File, WriteError, write);
</code></p>

<p>Hmm, this is interesting... is this function call returning a... type
definition? That is then assigned to <code>OutStream</code> and used as a return value for
<code>pub fn outStream</code>?</p>

<p>That's exactly what it's doing! In <code>lib/std/io/outStream.zig</code>:</p>

<p><code>zig
pub fn OutStream(
    comptime Context: type,
    comptime WriteError: type,
    comptime writeFn: fn (context: Context, bytes: []const u8) WriteError!usize,
) type {
    return struct {
        context: Context,
        //...
    }
}
</code></p>

<p>This is Zig's way of supporting generics! Given some compile time known values,
you can create a struct definition <em>on the fly, at compile time</em>. Here is a
more detailed post about that capability: <a href="https://kristoff.it/blog/what-is-zig-comptime/">What is Zig's
Comptime?</a>.</p>

<p>For now, take careful note that <code>write</code> is being passed to <code>io.OutStream</code> as
the <code>writeFn</code> argument, which will eventually be what is called to print to
standard out.</p>

<p>Alright, phew, so that's</p>

<p><code>zig
const stdout = std.io.getStdOut().outStream();
</code></p>

<p>We've ended up with an <code>OutStream</code> struct with its <code>context</code> field initialized
to the <code>File</code> struct returned by <code>std.io.getStdOut()</code>.</p>

<p>Now for the money business.</p>

<p><code>zig
try stdout.print(&quot;Hello, {}!\n&quot;, .{&quot;world&quot;});
</code></p>

<p>The definition of this &quot;instance method&quot; lives in <code>lib/std/io/outStream.zig</code>.</p>

<p><code>zig
pub fn print(self: Self, comptime format: []const u8, args: var) Error!void {
    return std.fmt.format(self, format, args);
}
</code>
This dispatces <code>self</code> to <code>std.fmt.format</code> along with two more arguments. Let's
look at that function</p>

<p><code>zig
pub fn format(
    out_stream: var,
    comptime fmt: []const u8,
    args: var,
) !void {
  //...
}
</code></p>

<p>Ok we're getting closer: <code>out_stream</code> is in our case, the <code>File</code> from way back
at the beginning.</p>

<blockquote>
<p><a href="https://andrewkelley.me">Andy</a> said: &quot;Almost - it's the file.outStream()
return value. Which is just the &quot;Context&quot; with the write function as part of
the type. The way streams work in zig right now is with &quot;duck typing&quot;. It
optimizes well, the API is mostly good, but it can produce bloated code, and
in some cases the API is annoyingly too generic. Sometimes it would be nice
to accept a non-&quot;var&quot; type as a stream parameter.&quot;</p>
</blockquote>

<p>The other two arguments are being passed in at the top level
call site, a string constant and an <a href="https://ziglang.org/documentation/0.6.0/#Anonymous-List-Literals">anonymous list
literal</a>
(whose behavior is unsurprisingly similar to the aformentioned anonymous struct
literal) of positional arguments meant to be interpolated into the format
string at points marked by <code>{}</code>. You can pass in <a href="https://ziglang.org/documentation/0.6.0/std/#std;fmt.format">formatting
options</a> much like
c's <code>printf</code>.</p>

<p><code>format</code> is a long function, there is a lot of bookeeping going on, but the
meat of it are its calls to <code>out_stream.writeAll</code>. Jumping back to that definition:</p>

<p><code>zig
pub fn writeAll(self: File, bytes: []const u8) WriteError!void {
    var index: usize = 0;
    while (index &lt; bytes.len) {
        index += try self.write(bytes[index..]);
    }
}
</code></p>

<p>We can see that it calls into <code>self.write</code>, which looks like:</p>

<p><code>zig
pub fn write(self: File, bytes: []const u8) WriteError!usize {
    if (is_windows) {
        return windows.WriteFile(self.handle, bytes, null, self.intended_io_mode);
    } else if (self.capable_io_mode != self.intended_io_mode) {
        return std.event.Loop.instance.?.write(self.handle, bytes);
    } else {
        return os.write(self.handle, bytes);
    }
}
</code></p>

<p>And now, finally, we're down to the <code>system</code> in <code>systems programming</code> This
method operates differently depending on the system it's being used on! At the
top of this file <code>lib/std/fs/file.zig</code>,</p>

<p><code>zig
const is_windows = std.Target.current.os.tag == .windows;
</code></p>

<p>I am not on windows, and I will for now ignore the second branch so I don't
have to get into <code>async</code>, so I end up here:</p>

<p><code>zig
return os.write(self.handle, bytes);
</code></p>

<p>I am calling into an os specific library function that accepts a place to write
bytes and bytes to write (by this point formatted with those interpolated
values from the call site). Here's where it gets good.</p>

<p><code>os.write</code> calls into <code>system.write</code> which is defined <em>per architecture</em></p>

<p><code>zig
pub const system = if (@hasDecl(root, &quot;os&quot;) and root.os != @This())
    root.os.system
else if (builtin.link_libc)
    std.c
else switch (builtin.os.tag) {
    .macosx, .ios, .watchos, .tvos =&gt; darwin,
    .freebsd =&gt; freebsd,
    .linux =&gt; linux,
    .netbsd =&gt; netbsd,
    .dragonfly =&gt; dragonfly,
    .wasi =&gt; wasi,
    .windows =&gt; windows,
    else =&gt; struct {},
};
</code></p>

<p>For me, that ends up being <code>linux</code>, defined here:</p>

<p><code>zig
pub const linux = @import(&quot;os/linux.zig&quot;);
</code></p>

<p>So in my case, <code>system.write</code> ends up as:</p>

<p><code>zig
pub fn write(fd: i32, buf: [*]const u8, count: usize) usize {
    return syscall3(.write, @bitCast(usize, @as(isize, fd)), @ptrToInt(buf), count);
}
</code></p>

<p>where <code>syscall3</code> is imported directly into the namespace according to architecture:</p>

<p><code>zig
pub usingnamespace switch (builtin.arch) {
    .i386 =&gt; @import(&quot;linux/i386.zig&quot;),
    .x86_64 =&gt; @import(&quot;linux/x86_64.zig&quot;),
    .aarch64 =&gt; @import(&quot;linux/arm64.zig&quot;),
    .arm =&gt; @import(&quot;linux/arm-eabi.zig&quot;),
    .riscv64 =&gt; @import(&quot;linux/riscv64.zig&quot;),
    .mips, .mipsel =&gt; @import(&quot;linux/mips.zig&quot;),
    else =&gt; struct {},
};
</code>
for me, that's <code>x86_64</code>, and it looks like this:</p>

<p><code>zig
pub fn syscall3(number: SYS, arg1: usize, arg2: usize, arg3: usize) usize {
    return asm volatile (&quot;syscall&quot;
        : [ret] &quot;={rax}&quot; (-&gt; usize)
        : [number] &quot;{rax}&quot; (@enumToInt(number)),
          [arg1] &quot;{rdi}&quot; (arg1),
          [arg2] &quot;{rsi}&quot; (arg2),
          [arg3] &quot;{rdx}&quot; (arg3)
        : &quot;rcx&quot;, &quot;r11&quot;, &quot;memory&quot;
    );
}
</code></p>

<p>Not so simple a program now, is it? Remember, these syscalls differ for each
architecture, the compiler produces machine code based on what you're
targeting, so this is just one of many possible paths. I think that it is easy
to forget how complicated that can become. We're down here in inline assembly
land already!</p>

<h2>Assembly program</h2>

<p>Let's come at this from a slightly different angle: bottom up. We know that the
zig compilers job, just like any compiler, is to take <em>source code</em> and turn it
into something else. Zig is highly portable; using llvm as a backend means
it can target basically anything that llvm targets, with the caveat that not
all library functions will have the same amount of support on all platforms
(see the <a href="https://ziglang.org/download/0.6.0/release-notes.html#Tier-System">support
table</a>) for
more detail on that).</p>

<p>So, there are many possible targets, and so there are many possible &quot;something
else&quot;s for the source to be turned into. But let's look at the most obvious
case: building an executable that targets my current running system.</p>

<p>The transformation pipeline inside the compiler goes from <code>source</code> -&gt;
<code>intermediate representation(s)</code> -&gt; <code>target</code>, where <code>intermediate
representations</code> could be many things and include many steps. Zig has its own
IR, as a matter of fact, on which it runs its own static analysis processes
before transforming it to LLVM IR and passing it along where is could be
processed through <a href="http://llvm.org/docs/Passes.html">many possible optimazation and compilation/assemblage
steps</a> (LLVM calls these &quot;passes&quot;).
<code>target</code>, for me, is x86<em>64 machine code, but the last stop </em>before_ that is
assembly.</p>

<p>Because clang is a full compiler toolchain built on llvm, and zig can be used
as a <a href="https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html">drop in replacement for
clang</a>,
we should be able to use <code>zig cc</code> to compile assembly code directly into machine code.
This step is actually called <em>assembling</em>, not compiling, and is done by an
&quot;assembler&quot; but tbh this is a <a href="http://composition.al/blog/2017/07/30/what-do-people-mean-when-they-say-transpiler/">distinction without much of a
difference</a></p>

<p>What is the advantage of using <code>zig cc</code>? Primarily that you are able to
reliably use the same toolchain and version of llvm that the version of zig you
are using relies on. No futzing around with system libraries and linkages, it's
all just ready to work.</p>

<p>I make an empty file:</p>

<p><code>
$ touch hello.s
</code></p>

<p><code>clang</code> is smart enough to detect a filetype by its extension, so, so is <code>zig cc</code>.</p>

<p><code>
$ zig cc hello.s
</code></p>

<p>```
zig: warning: argument unused during compilation: '-nostdinc' [-Wunused-command-line-argument]
zig: warning: argument unused during compilation: '-fno-spell-checking' [-Wunused-command-line-argument]
zig: warning: argument unused during compilation: '-fno-omit-frame-pointer' [-Wunused-command-line-argument]
zig: warning: argument unused during compilation: '-D <em>DEBUG' [-Wunused-command-line-argument]
zig: warning: argument unused during compilation: '-fstack-protector-strong' [-Wunused-command-line-argument]
zig: warning: argument unused during compilation: '--param ssp-buffer-size=4' [-Wunused-command-line-argument]
zig: warning: argument unused during compilation: '-isystem /usr/local/include' [-Wunused-command-line-argument]
zig: warning: argument unused during compilation: '-isystem /usr/include/x86</em>64-linux-gnu' [-Wunused-command-line-argument]
zig: warning: argument unused during compilation: '-isystem /usr/include' [-Wunused-command-line-argument]
lld: error: undefined symbol: main</p>

<blockquote>
<blockquote>
<blockquote>
<p>referenced by start.S:104 (/home/jfo/code/zig/build/lib/zig/libc/glibc/sysdeps/x86<em>64/start.S:104)
 /home/jfo/.cache/zig/stage1/o/ujWleITFBRHwV19Tq0gsSK</em>F<em>gRDc7-jgOCip86Un1bhdmx0pIXLGQRxtjMtuntC/Scrt1.o:(</em>start)</p>
</blockquote>
</blockquote>
</blockquote>

<p>```</p>

<p>Most of this is just telling us that the flags zig is passing to clang by
default weren't used for anything, which isn't much of a surprise since there
was nothing to compile! (Strictly speaking, this is a bug in the zig compiler,
but for our purposes it has no effect) There is a <em>real</em> error here, too.</p>

<p><code>
lld: error: undefined symbol: main
</code></p>

<p><code>lld</code> is the <a href="https://lld.llvm.org/"><em>linker</em></a> bundled with llvm bundled with
clang, and so bundled with zig, and it is complaining that this program (which
is empty) that we're trying to turn into an executable doesn't have an entry
point. How would you run it? Where would you start?</p>

<p>We can instead build an &quot;object file&quot; that isn't intended to be executable by
passing the <code>-c</code> flag.</p>

<blockquote>
<p>These options are the <em>same</em> options as clang, as all of these arguments are
simply being forwarded to clang along with the compiler flags set by zig as defaults.</p>
</blockquote>

<p><code>
$ zig cc -c hello.s
</code></p>

<p>This throws all the same warnings as before, but it succeeds, and produces
<code>hello.o</code>, an object file.</p>

<p>Running <code>file</code> on this output</p>

<p><code>
$ file hello.o
</code></p>

<p>Will tell us what we have got.</p>

<p><code>
hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
</code></p>

<p>This is essentially a bundle of machine code that would be suitable for linking
into other programs during their <a href="https://stackoverflow.com/questions/24655839/what-is-the-difference-between-executable-and-relocatable-in-elf-format">own linking
phase</a>,
if there was actually any code in there at all to be used. As it stands,
there's just the <a href="https://lwn.net/Articles/631631/">ELF header</a> to identify the
file type and what I assume to be a bit of metadata and some padding.</p>

<p>But we wanted to actually make an executable, so we need an entry point! What
does an entry point look like?</p>

<p>In x86 assembly, the default entry point looks like:</p>

<p><code>
_start:
</code></p>

<p>I add that to the file, and try again:</p>

<p><code>bash
$ zig cc hello.s
</code></p>

<p>and</p>

<p><code>
lld: error: undefined symbol: main
&gt;&gt;&gt; referenced by start.S:104 (/home/jfo/code/zig/build/lib/zig/libc/glibc/sysdeps/x86_64/start.S:104)
&gt;&gt;&gt;               /home/jfo/.cache/zig/stage1/o/ujWleITFBRHwV19Tq0gsSK_F_gRDc7-jgOCip86Un1bhdmx0pIXLGQRxtjMtuntC/Scrt1.o:(_start)
</code></p>

<p>(I have left out the assembler warnings from above).</p>

<p>What? If the default entry point is <code>_start</code>, why is it asking for <code>main</code>, then?</p>

<p>Looking at the error, it <em>is</em> trying to load <code>_start</code>, just not <em>our</em> start.
When you compile a regular zig or c program with a <code>main</code> function, your
program doesn't <em>actually</em> start at main, it <em>also</em> starts at <code>_start</code>, which
is responsible for doing memory setup and generally getting everything tidy for
you before your <code>main</code> function runs. Remember, here we're just using <code>zig cc</code>
as a pass through for clang, and so the <em>real</em> definition of <code>_start</code> resides
in libc, and looks like
<a href="https://github.com/jfo/zig/blob/master/lib/libc/glibc/sysdeps/x86_64/start.S">this</a>.</p>

<p>There are two ways I can solve this now. First, I can just make an assembly
file with <code>main:</code> instead... let's try that.</p>

<p><code>asm
main:
</code>
<code>bash
$ zig cc hello.s
</code></p>

<p><code>bash
lld: error: undefined symbol: main
&gt;&gt;&gt; referenced by start.S:104 (/home/jfo/code/zig/build/lib/zig/libc/glibc/sysdeps/x86_64/start.S:104)
&gt;&gt;&gt;               /home/jfo/.cache/zig/stage1/o/ujWleITFBRHwV19Tq0gsSK_F_gRDc7-jgOCip86Un1bhdmx0pIXLGQRxtjMtuntC/Scrt1.o:(_start)
</code></p>

<p>Ah, remember <code>pub fn main()</code>? In addition to being defined, this symbol also
needs to be available to the linker. In assembly, that means putting it as a
<code>.globl</code> declaration.</p>

<p><code>asm
.globl main
main:
</code></p>

<p>Without that, the assembler is free to discard the label since it thinks it's
not needed for any other steps.</p>

<p><code>bash
$ zig cc hello.s
</code></p>

<p>This assembles! When I run the resulting executable, I get:</p>

<p><code>
Trace/breakpoint trap (core dumped)
</code></p>

<p>This isn't surprising, I've written a program that does nothing. I'm not
particularly interested in this error right now, the important thing is that I
got this to assemble.</p>

<p>I'm also not interested in using the libc startup code and <code>_start</code> call; I
want to do everything myself.</p>

<p>I will try to definie my own <code>.globl _start</code>:</p>

<p><code>asm
.globl _start
_start:
</code></p>

<p><code>bash
$ zig cc hello.s
</code></p>

<p><code>
lld: error: duplicate symbol: _start
&gt;&gt;&gt; defined at start.S:63 (/home/jfo/code/zig/build/lib/zig/libc/glibc/sysdeps/x86_64/start.S:63)
&gt;&gt;&gt;            /home/jfo/.cache/zig/stage1/o/ujWleITFBRHwV19Tq0gsSK_F_gRDc7-jgOCip86Un1bhdmx0pIXLGQRxtjMtuntC/Scrt1.o:(_start)
&gt;&gt;&gt; defined at zig-cache/o/UbeRHF13NXWYrl3f0cuxy3OffVcjvaAbWr5e2svkLcYXPpPG03d4JplnyJU7tFJ7/empty.o:(.text+0x0)
</code></p>

<p>Given what we've seen so far, this makes complete sense. <code>_start</code> has already
been defined in the libc code, so simply putting it here results in this error,
because of course it does.</p>

<p>The linker takes an option to simply not use anything in the standard library,
which is exactly what I want.</p>

<p><code>bash
$ zig cc -nostdlib hello.s
</code>
<code>
./a.out
</code></p>

<p><code>
Segmentation fault (core dumped)
</code></p>

<p>Hello world!</p>

<hr />

<p>Alright, now I've sussed out the precise incantations to go directly from an
x86 assembly file (<code>.s</code>) to an executable. What is the <em>smallest assembly
program I can write?</em></p>

<blockquote>
<p>TODO: explain att/intel syntax and the directive.
delineate between intel syntax and att syntax... note how &quot;noprefix&quot; has no
effect in clang but needs to be available for gcc. att is the default, mention
nasm, what's the difference and who cares? Mention how hard it is to find good
resources, everything either assumes a lot of knowledge or is a reference
manual.</p>
</blockquote>

<p>That would be a program that simply exits.</p>

<p>```asm
.intel<em>syntax noprefix
.globl </em>start</p>

<p>_start:
 mov rax, 60
 syscall
```</p>

<p>What's happening here? I'm just putting <code>60</code> into the <code>rax</code> register, and then
making a <code>syscall</code>. The syscall looks at the <code>rax</code> register and does what the
code corresponds to, which is <code>sys_exit</code>, so the program exits, that's it.</p>

<p>When I compile and run this program, nothing happens, but
<code>[strace](https://jvns.ca/blog/2015/04/14/strace-zine/)</code> tells me that it's
doing exactly what I expected:</p>

<p><code>
zig cc -nostdlib empty.s &amp;&amp; strace ./a.out
</code></p>

<p><code>
execve(&quot;./a.out&quot;, [&quot;./a.out&quot;], 0x7ffd47b269c0 /* 104 vars */) = 0
exit(0)                                 = ?
+++ exited with 0 +++
</code></p>

<p>Futhermore, the <code>sys_exit</code> syscall looks in the <code>rdi</code> register to get the
<em>value</em> it returns to the calling process. I can put whatever I want in there
before executing the syscall.</p>

<p>```asm
.intel<em>syntax noprefix
.globl </em>start</p>

<p>_start:
 mov rdi, 0xface
 mov rax, 60
 syscall
```</p>

<p><code>
execve(&quot;./a.out&quot;, [&quot;./a.out&quot;], 0x7fffa91a9be0 /* 104 vars */) = 0
exit(64206)                             = ?
+++ exited with 206 +++
</code></p>

<p>You'll notice, that even though I loaded a 32 bit value into the register, and
<code>r</code> prefixed registers are 64 bits wide (todo citation), it only looked at the
bottom 8 bits. This leads me to believe that error codes must be between 1 and
255, is this correct?</p>

<p>Running this without strace, nothing happens, which surprised me actually. I
thought that <code>0</code> was a success code and anything else was an error code. This
is <a href="https://github.com/jfo/zig/blob/7381aaf70e0cad92fc52b79f3aa2a0abb7c3ee04/lib/libc/include/generic-glibc/stdlib.h#L91-L92">conventionally the
case</a>!
But it's up to the caller to interpret that code and respond to it. For my
little program, there is no error handling that reports back to the user what's
going on, it just dutifully exits with the value I gave it and that's that.</p>

<hr />

<p>Though the origins of the hello world are well known (it was the very <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">first
example</a> in the
hugely influential K&amp;R C book), the definition of a hello world has grown over
the years. Though the canonical example is still &quot;output the literal text
'Hello World!'&quot;, lots of paradigms and systems have their own version of it- my
favorite is the arduino <a href="https://www.arduino.cc/en/Tutorial/Blink">blink</a>; it's
the simplest thing you can do with it that proves it's working as intended.</p>

<p>By that measure, the above code is <em>already</em> an assembly hello world in that
we've compiled it and proved it works! But it's a very small step to get to a
<em>real</em> hello world, too.</p>

<p>Here it is!</p>

<p>```asm
.intel<em>syntax noprefix
.globl </em>start</p>

<p>_start:
 mov rax, 0x1
 mov rdi, 0x1
 lea rsi, msg
 mov rdx, 14
 syscall
 xor rdi, rdi
 mov rax, 60
 syscall
msg:
 .ascii &quot;Hello, world!\n&quot;
```</p>

<p>You can see that there's not really that much more here. A little more preamble
at the top, and then <em>two</em> syscalls instead of one, followed by a little data
section that actually holds the text we're printing to the screen. Let's go
through this, line by line.</p>

<p><code>asm
.intel_syntax noprefix
</code></p>

<p>Assembly comes in different flavors, afaict, <a href="https://stackoverflow.com/questions/972602/limitations-of-intel-assembly-syntax-compared-to-att">it doesn't really matter which
you use or
prefer</a>,
so here I have decided to use intel syntax.</p>

<p>An interesting note here, is that llvm <a href="https://github.com/llvm-mirror/llvm/blob/2c4ca6832fa6b306ee6a7010bfb80a3f2596f824/lib/Target/X86/AsmParser/X86AsmParser.cpp#L3563-L3584">doesn't need you to explicitly say <code>noprefix</code></a> but <code>gcc</code> <em>does</em>.</p>

<p>Trying to compile in gcc gives me errors:</p>

<p><code>
hello.s: Assembler messages:
hello.s:4: Error: ambiguous operand size for `mov'
hello.s:5: Error: ambiguous operand size for `mov'
hello.s:6: Error: too many memory references for `lea'
hello.s:7: Error: ambiguous operand size for `mov'
hello.s:9: Error: ambiguous operand size for `mov'
hello.s:10: Error: too many memory references for `xor'
</code></p>

<p>but it works just fine with clang.</p>

<p><code>asm
.globl  _start
</code></p>

<p>We know this one: marking the <code>_start</code> symbol available to the linker.</p>

<p>Next, on the the body of the program:</p>

<p><code>asm
_start:
  mov     rax, 0x1
  mov     rdi, 0x1
  lea     rsi, msg
  mov     rdx, 14
  syscall
</code></p>

<p>Looking at <a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">this chart of linux
syscalls</a>,
I can see that what is going to be in <code>rax</code> when I reach <code>syscall</code> is <code>1</code>,
which corresponds to the <code>SYSWRITE</code> system call. It's &quot;arguments&quot; live in the
registers <code>rdi</code>, <code>rsi</code>, and <code>rdx</code>:</p>

<p><code>
%rax    System call %rdi    %rsi    %rdx
1   sys_write   unsigned int fd const char *buf size_t count
</code></p>

<p>Where <code>fd</code> (file descriptor) is for the <em>output stream</em>, <code>buf</code> is a <em>pointer to
the buffer from which we want to write</em> and <code>count</code> is the <em>number of bytes we
want to write</em>.</p>

<p>What are we putting into those registers, then?</p>

<p>In <code>rax</code>, we insert the syscall number for sys_write: <code>1</code></p>

<p><code>rdi</code>: The file descriptor for <code>stdout</code>, <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_(stdout)">defined by
POSIX</a>
to be <code>1</code></p>

<p><code>rsi</code>: a pointer to the buffer we write from. Here, we see the <a href="https://stackoverflow.com/a/57796189/2727670"><code>lea</code>
instruction</a> for &quot;load effective
address&quot;, and the right hand value is a label <code>msg</code> that is defined at the bottom of the file:</p>

<p><code>
msg:
  .ascii  &quot;Hello, world!\n&quot;
</code></p>

<p>Finally, in <code>rdx</code> we put in <code>14</code>, the length of the buffer. It is not runtime
known, since there is no runtime!</p>

<p>With all of these loaded into the appropriate registers,</p>

<p><code>
syscall
</code></p>

<p>Executes <code>sys_write</code> and writes the contents of the memory buffer to stdout.</p>

<p>The remaining three lines:</p>

<p><code>asm
xor     rdi, rdi
mov     rax, 60
syscall
</code></p>

<p>Might be familiar; we're loading something into <code>rdi</code> and calling <code>sys_exit</code>
(60), just like the first example. In this case though, we're <code>xor</code>ing <code>rdi</code>
with itself, which is the same thing as setting it to <code>0</code>: the success code.</p>

<p>And that's it!</p>

<p>TODO: map this asm to the zig output.</p>

<hr />

<p>https://stackoverflow.com/questions/17898989/what-is-global-start-in-assembly-language#comment26144653_17899048</p>
